#!/usr/bin/env ruby
# generate DOT file from the relation data generated by `generate_relation_data`.
# Only includes "red" links with clustering information added
# can then be used to generate the 2D relation map using gvmap the way below:
#
# dot -Ksfdp -Txdot -o output_span_nc_sfdp.xdot love_span_nc.dot
# gvmap -e output_span_nc_sfdp.xdot | neato -n2 -Tsvg >! test_sfdp.svg
#
# the generated SVG might need some post processing to fix colours

BLOGS = {}
BLOGS_IN = {}
BLOGS_OUT = {}

BLOGS_IN2 = {}
BLOGS_OUT2 = {}

CLUSTERS = { }

RED_EDGES = []
EMPTY_EDGES = []
CIRCULAR_EDGES = []


ARGF.each_line do |line|
  if line =~ /^(.*) (.*) all (.*) (.*)$/
    blog1name = $1
    blog1 = blog1name.tr('-','_')

    blog2name = $2
    blog2 = blog2name.tr('-','_')

    weight = $3

    blog1 = "_"+blog1 if blog1 =~ /^[0-9]/
    blog2 = "_"+blog2 if blog2 =~ /^[0-9]/

    BLOGS[blog1] ||= { name: blog1name }
    BLOGS[blog2] ||= { name: blog2name }

    BLOGS[blog1][:likes] ||= []
    BLOGS[blog2][:likes] ||= []

    BLOGS[blog1][:likes] << blog2

    next if BLOGS_OUT[blog1]

    BLOGS_IN[blog2] ||= {}
    BLOGS_IN[blog2][blog1] = weight.to_i

    BLOGS_IN2[blog2] ||= {}
    BLOGS_IN2[blog2][blog1] = weight.to_i

    BLOGS_OUT[blog1] = { name: blog2, weight: weight.to_i }
    BLOGS_OUT2[blog1] = { name: blog2, weight: weight.to_i }
  end
end

# find circular edges with one length, and remove them from the graph
BLOGS_OUT.each_pair do |blog1, values|
  blog2 = values[:name]
  if BLOGS_OUT[values[:name]]&.dig(:name) == blog1
    if !BLOGS[blog1][:cluster]
      BLOGS[blog1][:cluster] = "#{blog1}_#{blog2}"
    end
    if !BLOGS[blog2][:cluster]
      BLOGS[blog2][:cluster] = "#{blog1}_#{blog2}"
    end
    CLUSTERS["#{blog1}_#{blog2}"] = {name: "#{BLOGS[blog1][:name]} & #{BLOGS[blog2][:name]}", id: nil, count: 0 }
    RED_EDGES << [ blog1, blog2, values[:weight] ]
  end
end

RED_EDGES.each do |edge|
  BLOGS_OUT.delete(edge[0])
  BLOGS_IN.delete(edge[0])
end

old_count = 0

while old_count != BLOGS_OUT.count
  old_count = BLOGS_OUT.count
  # find edges that are connected to nodes that don't have this as an input

  BLOGS_OUT.each_pair do |blog1, values|
    if !BLOGS_IN[blog1] || BLOGS_IN[blog1].empty?
      EMPTY_EDGES << [ blog1, values[:name], values[:weight] ]
    end
  end

  EMPTY_EDGES.each do |edge|
    BLOGS_OUT.delete(edge[0])
    BLOGS_IN.dig(edge[1])&.delete(edge[0])
  end

  # find edges that are connected to nodes that don't have an output

  BLOGS_OUT.each_pair do |blog1, values|
    if !BLOGS_OUT[values[:name]]
      EMPTY_EDGES << [ blog1, values[:name], values[:weight] ]
    end
  end

  EMPTY_EDGES.each do |edge|
    BLOGS_OUT.delete(edge[0])
    BLOGS_IN.dig(edge[1])&.delete(edge[0])
  end
end

orphan = 0

count = nil
old_count = 0
while count != 0
  if old_count == count
    BLOGS.each_pair do |blog, value|
      if !value[:cluster]
        orphan += 1
        BLOGS[blog][:cluster] = "orphan_#{orphan}"
        CLUSTERS["orphan_#{orphan}"] = { name: "Orphan No #{orphan}", id: nil, count: 0 }
        break;
      end
    end
  end

  old_count = count
  count = 0
  BLOGS.each_pair do |blog, value|
    if value[:cluster]
      if BLOGS_IN2[blog]
        BLOGS_IN2[blog].each_pair do |blog2, value2|
          BLOGS[blog2][:cluster] = value[:cluster]
        end
      end
    else
      count += 1
    end
  end

  #STDERR.puts count
end

puts "digraph G {"
puts <<END
  graph [ overlap=false; outputorder=edgesfirst; sep="+40,40"; ];
  edge [ color="#00000044"; dir=both; arrowsize = 2; arrowhead=vee; arrowtail=invdot ];
  node [ fillcolor=white; style=filled, fontname="Helvetica Neue LT Pro", shape=box ];
END

id = 0
CLUSTERS.each_pair do |cluster, cldata|
  id += 1
  cldata[:id] = id
  #puts "subgraph cluster#{cluster} {"
  BLOGS.each_pair do |blog, data|
    if data[:cluster] == cluster
      puts "#{blog} [ label = \"#{data[:name]}\"; cluster = #{id} ];"
      cldata[:count] += 1
    end
  end

  RED_EDGES.each do |edge|
    if BLOGS[edge[0]][:cluster] == cluster
      puts "#{edge[0]} -> #{edge[1]} [weight=#{edge[2]} penwidth = 1.5; color=\"#660000FF\"];"
    end
  end

  EMPTY_EDGES.each do |edge|
    if BLOGS[edge[0]][:cluster] == cluster
      if BLOGS[edge[1]][:likes].include?(edge[0])
        puts "#{edge[0]} -> #{edge[1]} [weight=#{edge[2]}; color=\"#000000BB\" ];"
      else
        puts "#{edge[0]} -> #{edge[1]} [weight=#{edge[2]} ];"
      end
    end
  end

  #puts " label = \"#{cldata[:name]}\""
  #puts "}"
end

# BLOGS.each_pair do |blog, data|
#   puts "#{blog} [ label = \"#{data[:name]}\" ];"
# end

puts "}"

STDERR.puts "Cluster statistics:"
total = 0
CLUSTERS.values.sort_by{|d| d[:count]}.each do |d|
  STDERR.puts "%d / %0.2f%%: %s]" % [d[:count], d[:count].to_f / BLOGS.keys.count.to_f * 100, d[:name]]

  total += d[:count]
end